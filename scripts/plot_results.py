# Ref: https://stackoverflow.com/questions/62678601/how-to-plot-all-dataframes-from-a-dictionary-of-dataframes
# Ref: https://stackabuse.com/seaborn-line-plot-tutorial-and-examples/
import os 
import glob
import argparse
import pandas as pd

import seaborn as sns
import matplotlib.pyplot as plt

import cpuinfo

usage = '''example:
     python3 plot_results.py -i '/path/to/dir benchmark csv files generated by launch_results_parser.py' 
          -config <path to benchmarking config settings
          -o <optional: path to output dir to save summary_results.csv>
     '''
parser = argparse.ArgumentParser(prog='plot_results.py',
                            description='Arrange row/column results data for plotting',
                            epilog=usage)
args = parser.add_argument_group('Options')
args.add_argument('-i', '--input_dir', help='Benchmark csv files directory path', required=True)
args.add_argument('-o', '--output_dir', help='Output results summary file .csv', required=False, type=str, default='result_summary.csv & plot_results.csv')

def main():
     args = parser.parse_args()

     ## Get CPU info to be added to the plots
     cpu_info = cpuinfo.get_cpu_info()
     cpu_brand = cpu_info['brand_raw']
     num_cores = cpu_info['count']

     ## Plotting the results for each backend (for ex. OpenVINO, PyTorch etc) and model separately
     ## Requires filtering results for each unique backend
     ## And then copy the results for each backend into a list of backend specific dataframes 
     for file_name in os.listdir(args.input_dir):
          model_name = file_name.split('.')[0]
          df = pd.read_csv(os.path.join(args.input_dir, file_name), encoding = "utf-8")
          backends = df['backend'].unique()

          data_frames = {}
          for b in backends:
               back_df = df.loc[df['backend'].str.contains(b), :]
               data_frames[b] = back_df
          
          # create color mapping based on all unique latency values
          unique_vals = {latency for v in data_frames.values() for latency in df['latency_mean (ms)'].unique()}  # get unique values
          colors = sns.color_palette('husl', n_colors=len(unique_vals))  # get a number of colors
          cmap = dict(zip(unique_vals, colors))  # zip values to colors

          num_rows, num_cols = len(backends), 1
          num_plots = len(backends)
          
          plt.subplots(num_plots, sharex=True, sharey=True)
          
          plt.rcParams["figure.figsize"] = (10,10)

          for i, (backend_, dfs) in enumerate(data_frames.items(), 1):
               plt.subplot(num_rows, num_cols, i)
               subplt = sns.scatterplot(data=dfs, x='seq_len', y='latency_mean (ms)', hue='latency_mean (ms)', palette=cmap)
               subplt.set_xticklabels(sorted(dfs['seq_len']))
               #subplt.set_xticks(pos: val for pos, val in enumerate(dfs['seq_len']))
               #formatter = FuncFormatter(lambda x, pos: f"{x}, {pos}")
               plt.title(f'{backend_} perf on {cpu_brand}')

          plt.tight_layout()

          results_path = os.path.join(args.output_dir, f'{model_name}.png')
          plt.savefig(results_path)

if __name__ == '__main__':
    main()